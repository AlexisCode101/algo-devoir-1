\documentclass[12pt]{article}

\usepackage{vmargin}
\usepackage{setspace}
\usepackage[ruled, linesnumbered, french, onelanguage]{algorithm2e}
\usepackage{amsmath, amsthm, amssymb}

\title{Devoir 1}
\author{Jérémy Bouchard}
\date{\today}

\begin{document}

  \begin{titlepage}
    \doublespacing
    \centering

    UNIVERSITÉ DU QUÉBEC À CHICOUTIMI \\

    \vspace{4.7cm}

    DEVOIR 1 \\

    \vspace{4.7cm}

    PAR \\
    JÉRÉMY BOUCHARD (BOUJ08019605) \\
    ALEXANDRE LAROUCHE (LARA04119705) \\
    JEAN-PHILIPPE SAVARD (SAVJ04079609) \\
    ALEXIS VALOTAIRE (VALA) \\

    \vspace{4.7cm}

    DEVOIR PRÉSENTÉ À \\
    M. FRANÇOIS LEMIEUX \\
    DANS LE CADRE DU COURS D'ALGORITHMIQUE (8INF433)

  \end{titlepage}

  \newpage

  \newpage

  \pagenumbering{arabic}
  \onehalfspacing

  \section*{Question 1}

  \newpage

  \section*{Question 2}
  \subsection*{a)}

    Il est possible d'exprimer le pseudo-code de l'algorithme décrit dans
    l'énoncé de la question 2. Il est également possible de constater qu'il
    s'agit de l'algorithme du tri par selection. Celui-ci ce décrit de cette
    façon : \newline

    \begin{algorithm}[H]
      \KwData{\( T[1 \cdot\cdot\cdot  n] \)}
      \KwResult{\( T[1 \cdot\cdot\cdot  n] \) (Trié)}
        \For{\( j \gets 1 $ \KwTo $ n - 1 \)}{
          \( petit \gets j \)\\
          \For{\( i \gets j + 1 \) \KwTo \( n \)}{
            \If{\( T[i] < T[petit]\ \)}{
              \( petit \gets i \)\
            }
          }
          \( T[j] \leftrightarrow T[petit] \)
        }
      \caption{Pseudo-code du numéro 2}
    \end{algorithm}

  \subsection*{b)}

    Il est possible de calculer le temps d'exécution de cette algorithme
    facilement. En effet, pour chaque élément du tableau il est necessaire de
    parcourir le reste du tableau moins les éléments déjà triés. Donc, pour la
    première itération, il est nécessaire de réaliser \( (n - 1) \) comparaisons.
    Pour la deuxième itération, cela sera \( (n - 2) \) itérations et ainsi de
    suite jusqu'à ce qu'il ne reste que une seule valeur à trier. Il est donc
    possible de formaliser le temps d'exécution de cette manière :

    \[ (n - 1) + (n - 2) + (n - 3) + ... + 1 = \sum _ {i=1} ^ {n - 1} i \]

    Il ne reste qu'à trouver l'ordre de \( \sum _ {i=1} ^ {n - 1} i \). \newpage

    \begin{proof}[Temps d'exécution de l'algorithme de tri]
      \begin{align*}
        S   &= \sum _ {i=1} ^ {n - 1} i \\
            &= (n - 1) + (n - 2) + (n - 3) + ... + 1 \\
        2S  &= (n - 1) + (n - 2) + (n - 3) + ... + 1 \\
            &\qquad\,\, + 1 \qquad\;\:\, + 2 \qquad\;\:\, + 3 \;+ ... + (n - 1) \\
            &= \underbrace{(n + n + n + ... + n)}_\textrm{\( (n - 1) \) fois} \\
            &= (n - 1)(n) \\
        S   &= \frac{n(n - 1)}{2} \\
            &= \frac{1}{2}n^2 - \frac{1}{2}n
      \end{align*}
      \( D'o\grave{u} \ \mathcal{O}(n^2) \)
    \end{proof}

  \newpage

  \section*{Question 3}

  \newpage

  \section*{Question 4}
	 \subsection*{Temps d'exécution}
    Pour déterminer le temps d'exécution de l'algorithme tel qu'écrit dans l'énoncer, 
    il faut avant tout l'analyser ligne par ligne.
    
    ~\begin{proof}[Ligne 1: ``d=0'']
    	Une affection en informatique se fait en un temps constant (1).
    \end{proof}
     
     ~\begin{proof}[Ligne 2: ``tantque (X \textgreater  Y) faire \{...\}'']
	L'analyse de cette ligne est beaucoup plus difficile à faire, puisque nous
	ne savons pas comment la condition sortie est modifiée. Nous le serons
	au moment de l'analyse du contenu de la boucle. \newline
	
	Avec l'analyse du contenu de la boucle, on découvre qu'elle est exécutée
	`n` fois, basée sur la différence de X et Y. Ainsi, on peut conclure qu'elle
	est exécutée en un temps linéaire (n).
    \end{proof}
    
     ~\begin{proof}[Ligne 3: ``Soustraction(X,Y)'']
	Il est mentionné dans l'énoncé que cette fonction est exécuté en un temps
	linéaire (n).
    \end{proof}
    
    ~\begin{proof}[Ligne 4: ``d=d+1'']
    	Une affection et une addition en informatique se font en un temps constant (1).
    \end{proof}

    ~\begin{proof}[Ligne 5: ``return d'']
    	Un retour en informatique se fait en un temps constant (1).
    \end{proof}
    \ \\
    \noindent Ainsi, nous savons que: \newline
    1. Le temps d'exécution du contenu de la boucle est de $n + 1$; \newline
    2. Le contenu de la boucle est exécuté `n` fois, donc $n(n + 1)$; \newline
    3. Le reste de l'algorithme est en temps constant, donc $n(n + 1) + 1$. \newline
    \ \\
    En distribuant le tout, nous avons $n^{2}+n+1$. Donc le temps d'exécution est
     de l'ordre de \( \mathcal{O}(n^2) \).
    
   \subsection*{Efficacité de l'algorithme}
   	Est-ce que l'algorithme est efficace? La réponse est non. En effet, avec
   	l'analyse du temps d'exécution fait précédement, nous avons déterminé
   	que dans le pire des cas, le temps d'exécution est de l'ordre 
   	de \( \mathcal{O}(n^2) \). \newline
   	
   	Bien qu'un algorithme de cet ordre est généralement acceptable, 
   	il est mentionné dans l'énoncé que les variables X et Y sont de grands 
   	entiers. On peut conclure que le pire des cas se produira relativement
   	 souvent à l'exécution de l'algorithme, ce qui n'est pas vraiment acceptable. \newline
   	 
   	 Pour bien faire, il faudrait que la fonction `Soustraction(X,Y)` soit exectuable
   	 dans un temps constant au lieu de linéaire, ce qui réduirait le temps d'éxectuion
   	 dans l'ordre de \( \mathcal{O}(n) \) qui est beaucoup plus acceptable avec
   	 de grandes valeurs. 
   	
  \newpage

  \section*{Question 5}

  \newpage

\end{document}
